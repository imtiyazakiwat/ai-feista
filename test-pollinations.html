<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Pollinations.AI Integration</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #1a1a1a;
            color: #00ff00;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #00ff00;
            border-radius: 5px;
        }
        .success { border-color: #00ff00; color: #00ff00; }
        .error { border-color: #ff0000; color: #ff0000; }
        .info { border-color: #ffff00; color: #ffff00; }
        .warning { border-color: #ff8800; color: #ff8800; }
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: monospace;
            font-weight: bold;
        }
        button:hover {
            background: #00cc00;
        }
        #output {
            max-height: 500px;
            overflow-y: auto;
            background: #000;
            padding: 10px;
            margin-top: 20px;
            border: 1px solid #00ff00;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <h1>Pollinations.AI Integration Test</h1>
    
    <div>
        <button onclick="testPollinationsProvider()">Test Pollinations Provider</button>
        <button onclick="testChatGPT()">Test ChatGPT (via Pollinations)</button>
        <button onclick="testGemini()">Test Gemini (via Pollinations)</button>
        <button onclick="testAllModels()">Test All Available Models</button>
        <button onclick="testGPT4FreeWithFallback()">Test GPT4Free with Fallback</button>
        <button onclick="clearOutput()">Clear Output</button>
    </div>
    
    <div id="output"></div>
    
    <!-- Load Pollinations Provider -->
    <script src="js/pollinations-provider.js"></script>
    
    <!-- Load GPT4Free with fallback -->
    <script type="module">
        // Try to import GPT4Free, but don't fail if unavailable
        try {
            const { Client } = await import('https://g4f.dev/dist/js/client.js');
            window.GPT4FreeClient = Client;
        } catch (e) {
            console.log('GPT4Free client not available, will use Pollinations fallback');
        }
    </script>
    
    <!-- Load the integration -->
    <script src="js/gpt4free-integration.js"></script>
    
    <script>
        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            
            // Handle objects and errors
            let displayMessage = message;
            if (typeof message === 'object') {
                displayMessage = JSON.stringify(message, null, 2);
            }
            
            div.innerHTML = `<pre>[${timestamp}] ${displayMessage}</pre>`;
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
        }
        
        function clearOutput() {
            document.getElementById('output').innerHTML = '';
            log('Output cleared', 'info');
        }
        
        async function testPollinationsProvider() {
            log('Testing Pollinations Provider...', 'info');
            
            try {
                const provider = new PollinationsProvider();
                log('Pollinations provider created', 'success');
                
                // Test availability
                const isAvailable = await provider.isAvailable();
                if (isAvailable) {
                    log('Pollinations.AI is available', 'success');
                } else {
                    log('Pollinations.AI is not available', 'error');
                    return;
                }
                
                // Test model mappings
                const mappings = {
                    'chatgpt': provider.mapModel('chatgpt'),
                    'gpt-4': provider.mapModel('gpt-4'),
                    'gemini': provider.mapModel('gemini'),
                    'claude': provider.mapModel('claude'),
                    'grok': provider.mapModel('grok'),
                    'deepseek': provider.mapModel('deepseek')
                };
                
                log('Model mappings:', 'info');
                for (const [original, mapped] of Object.entries(mappings)) {
                    if (mapped === null) {
                        log(`  ${original} -> NOT AVAILABLE`, 'warning');
                    } else {
                        log(`  ${original} -> ${mapped}`, 'info');
                    }
                }
                
            } catch (error) {
                log(`Error: ${error.message}`, 'error');
            }
        }
        
        async function testChatGPT() {
            log('Testing ChatGPT via Pollinations...', 'info');
            
            try {
                const provider = new PollinationsProvider();
                
                await provider.sendMessage(
                    'chatgpt',
                    [{ role: 'user', content: 'Say "Hello from ChatGPT via Pollinations!" in exactly those words.' }],
                    (chunk, fullText) => {
                        // Streaming update
                    },
                    (result) => {
                        log(`ChatGPT Response: ${result.text}`, 'success');
                        log(`Provider: ${result.provider}`, 'info');
                    },
                    (error) => {
                        log(`ChatGPT Error: ${error.message}`, 'error');
                    },
                    false // No streaming for cleaner test output
                );
            } catch (error) {
                log(`Exception: ${error.message}`, 'error');
            }
        }
        
        async function testGemini() {
            log('Testing Gemini via Pollinations...', 'info');
            
            try {
                const provider = new PollinationsProvider();
                
                await provider.sendMessage(
                    'gemini',
                    [{ role: 'user', content: 'Say "Hello from Gemini via Pollinations!" in exactly those words.' }],
                    (chunk, fullText) => {
                        // Streaming update
                    },
                    (result) => {
                        log(`Gemini Response: ${result.text}`, 'success');
                        log(`Provider: ${result.provider}`, 'info');
                    },
                    (error) => {
                        log(`Gemini Error: ${error.message}`, 'error');
                    },
                    false // No streaming for cleaner test output
                );
            } catch (error) {
                log(`Exception: ${error.message}`, 'error');
            }
        }
        
        async function testAllModels() {
            log('Testing all available models on Pollinations...', 'info');
            
            const provider = new PollinationsProvider();
            const testModels = ['openai', 'gemini', 'mistral', 'qwen-coder'];
            
            for (const model of testModels) {
                log(`Testing ${model}...`, 'info');
                
                try {
                    await new Promise((resolve) => {
                        const timeout = setTimeout(() => {
                            log(`${model} timed out`, 'warning');
                            resolve();
                        }, 10000);
                        
                        provider.sendMessage(
                            model,
                            [{ role: 'user', content: `Say "Hello from ${model}!" in exactly those words.` }],
                            (chunk, fullText) => {
                                // Streaming update
                            },
                            (result) => {
                                clearTimeout(timeout);
                                log(`${model}: ${result.text}`, 'success');
                                resolve();
                            },
                            (error) => {
                                clearTimeout(timeout);
                                log(`${model} Error: ${error.message}`, 'error');
                                resolve();
                            },
                            false
                        );
                    });
                } catch (error) {
                    log(`${model} Exception: ${error.message}`, 'error');
                }
            }
            
            log('All models tested', 'info');
        }
        
        async function testGPT4FreeWithFallback() {
            log('Testing GPT4Free with Pollinations fallback...', 'info');
            
            // Wait for integration to initialize
            let attempts = 0;
            while (!window.gpt4FreeIntegration && attempts < 30) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            if (!window.gpt4FreeIntegration) {
                log('GPT4Free integration not loaded', 'error');
                return;
            }
            
            const integration = window.gpt4FreeIntegration;
            
            // Check which provider is being used
            if (integration.usingPollinations) {
                log('Using Pollinations.AI as primary provider', 'warning');
            } else {
                log('Using GPT4Free as primary provider', 'success');
            }
            
            // Test sending a message
            try {
                await integration.sendMessageToModel(
                    'chatgpt',
                    'Say "Hello from integrated system!"',
                    (chunk, fullText) => {
                        // Streaming
                    },
                    (result) => {
                        log(`Response: ${result.text}`, 'success');
                        log(`Model: ${result.model}, Provider: ${result.provider || 'gpt4free'}`, 'info');
                    },
                    (error) => {
                        log(`Error: ${error.message}`, 'error');
                    },
                    false
                );
            } catch (error) {
                log(`Exception: ${error.message}`, 'error');
            }
        }
        
        // Auto-test on load
        window.addEventListener('load', () => {
            log('Test page loaded', 'info');
            log('Click buttons above to test different components', 'info');
        });
    </script>
</body>
</html>
