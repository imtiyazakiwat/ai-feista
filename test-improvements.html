<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Improvements - Timeout, Parallel Requests, Duplicate Fix</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .response {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            min-height: 100px;
            white-space: pre-wrap;
            font-family: monospace;
            border: 1px solid #e9ecef;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .status {
            padding: 5px 10px;
            border-radius: 3px;
            margin: 5px 0;
            font-weight: bold;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        .warning { background: #fff3cd; color: #856404; }
        .model-card {
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 10px 0;
            padding: 10px;
            background: #f9f9f9;
        }
        .model-header {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .timing-info {
            font-size: 0.9em;
            color: #666;
            margin: 5px 0;
        }
        .first-response {
            border-color: #28a745;
            background: #d4edda;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Improvements Test</h1>
        <p>Testing the fixes for timeout issues, parallel requests, and duplicate prompt problems.</p>
        
        <div class="test-section">
            <h3>Test 1: GPT-5 Timeout Fix</h3>
            <p>This should no longer timeout with the increased timeout duration.</p>
            <button onclick="testGPT5Timeout()" id="gpt5Btn">Test GPT-5 (Long Response)</button>
            <div id="gpt5Status" class="status info" style="display: none;">Testing GPT-5 timeout...</div>
            <div id="gpt5Response" class="response"></div>
        </div>

        <div class="test-section">
            <h3>Test 2: Parallel Requests & First Response</h3>
            <p>Multiple models should respond in parallel, with the first response highlighted.</p>
            <button onclick="testParallelRequests()" id="parallelBtn">Test Parallel Requests</button>
            <div id="parallelStatus" class="status info" style="display: none;">Testing parallel requests...</div>
            <div id="parallelResults"></div>
        </div>

        <div class="test-section">
            <h3>Test 3: Duplicate Prompt Fix</h3>
            <p>This should send the prompt only once, not twice.</p>
            <button onclick="testDuplicateFix()" id="duplicateBtn">Test Duplicate Fix</button>
            <div id="duplicateStatus" class="status info" style="display: none;">Testing duplicate fix...</div>
            <div id="duplicateResponse" class="response"></div>
        </div>

        <div class="test-section">
            <h3>Test 4: Performance Comparison</h3>
            <p>Compare old vs new behavior.</p>
            <button onclick="runPerformanceTest()" id="perfBtn">Run Performance Test</button>
            <div id="perfResults" class="response"></div>
        </div>
    </div>

    <script>
        let testResults = {
            gpt5: { startTime: null, endTime: null, success: false },
            parallel: { startTime: null, endTime: null, firstResponse: null, allResponses: [] },
            duplicate: { startTime: null, endTime: null, success: false }
        };

        // Test GPT-5 timeout fix
        async function testGPT5Timeout() {
            const btn = document.getElementById('gpt5Btn');
            const status = document.getElementById('gpt5Status');
            const response = document.getElementById('gpt5Response');
            
            btn.disabled = true;
            status.style.display = 'block';
            status.textContent = 'Testing GPT-5 timeout (this may take up to 2.5 minutes)...';
            status.className = 'status info';
            response.textContent = '';
            
            testResults.gpt5.startTime = Date.now();
            
            try {
                const res = await fetch('/api/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        path: 'http://13.61.23.21:8080/v1/chat/completions',
                        method: 'POST',
                        headers: {
                            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0IjoiYXUiLCJ2IjoiMC4wLjAiLCJ1dSI6IlYyaG1GM3U4VEpHNXFiNURieUlLM0E9PSIsImF1IjoiaWRnL2ZEMDdVTkdhSk5sNXpXUGZhUT09IiwicyI6ImhyWWJtT29TZFBIOGJQbU4wc2owNGc9PSIsImlhdCI6MTc1NzUwMzE5MH0.yGGnALj9j5aQsZeS59xT5glNfwezMxC3w2oxqiCUpo0'
                        },
                        body: {
                            model: 'gpt-5-2025-08-07',
                            messages: [{ role: 'user', content: 'Write a detailed 500-word essay about the future of artificial intelligence. Include specific examples and predictions.' }],
                            max_tokens: 1000,
                            stream: true
                        }
                    })
                });

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${await res.text()}`);
                }

                const reader = res.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let fullText = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.trim() === '' || line.trim() === 'data: [DONE]') continue;
                        
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                const chunk = data.choices?.[0]?.delta?.content;
                                
                                if (chunk) {
                                    fullText += chunk;
                                    response.textContent = fullText;
                                }
                            } catch (e) {
                                console.warn('Error parsing chunk:', e);
                            }
                        }
                    }
                }

                testResults.gpt5.endTime = Date.now();
                testResults.gpt5.success = true;
                
                const totalTime = testResults.gpt5.endTime - testResults.gpt5.startTime;
                status.textContent = `‚úÖ GPT-5 completed successfully in ${totalTime}ms (no timeout!)`;
                status.className = 'status success';

            } catch (error) {
                testResults.gpt5.endTime = Date.now();
                const totalTime = testResults.gpt5.endTime - testResults.gpt5.startTime;
                status.textContent = `‚ùå Error after ${totalTime}ms: ${error.message}`;
                status.className = 'status error';
                console.error('GPT-5 test error:', error);
            } finally {
                btn.disabled = false;
            }
        }

        // Test parallel requests
        async function testParallelRequests() {
            const btn = document.getElementById('parallelBtn');
            const status = document.getElementById('parallelStatus');
            const results = document.getElementById('parallelResults');
            
            btn.disabled = true;
            status.style.display = 'block';
            status.textContent = 'Testing parallel requests...';
            status.className = 'status info';
            results.innerHTML = '';
            
            testResults.parallel.startTime = Date.now();
            let firstResponseTime = null;
            let responseCount = 0;
            
            const models = ['chatgpt', 'gemini', 'deepseek'];
            const responses = {};
            
            // Create model cards
            models.forEach(modelId => {
                const card = document.createElement('div');
                card.className = 'model-card';
                card.id = `card-${modelId}`;
                card.innerHTML = `
                    <div class="model-header">${modelId.toUpperCase()}</div>
                    <div class="timing-info">Waiting for response...</div>
                    <div class="response" id="response-${modelId}"></div>
                `;
                results.appendChild(card);
            });
            
            try {
                // Simulate parallel requests (using the actual integration if available)
                const promises = models.map(async (modelId) => {
                    const startTime = Date.now();
                    
                    try {
                        const res = await fetch('/api/stream', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                path: 'http://13.61.23.21:8080/v1/chat/completions',
                                method: 'POST',
                                headers: {
                                    'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0IjoiYXUiLCJ2IjoiMC4wLjAiLCJ1dSI6IlYyaG1GM3U4VEpHNXFiNURieUlLM0E9PSIsImF1IjoiaWRnL2ZEMDdVTkdhSk5sNXpXUGZhUT09IiwicyI6ImhyWWJtT29TZFBIOGJQbU4wc2owNGc9PSIsImlhdCI6MTc1NzUwMzE5MH0.yGGnALj9j5aQsZeS59xT5glNfwezMxC3w2oxqiCUpo0'
                                },
                                body: {
                                    model: modelId === 'chatgpt' ? 'gpt-5-2025-08-07' : 
                                          modelId === 'gemini' ? 'gemini' : 'deepseek-v3-0324',
                                    messages: [{ role: 'user', content: 'Write a short 2-sentence response about AI.' }],
                                    max_tokens: 100,
                                    stream: true
                                }
                            })
                        });

                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}`);
                        }

                        const reader = res.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = '';
                        let fullText = '';

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop() || '';

                            for (const line of lines) {
                                if (line.trim() === '' || line.trim() === 'data: [DONE]') continue;
                                
                                if (line.startsWith('data: ')) {
                                    try {
                                        const data = JSON.parse(line.slice(6));
                                        const chunk = data.choices?.[0]?.delta?.content;
                                        
                                        if (chunk) {
                                            fullText += chunk;
                                            document.getElementById(`response-${modelId}`).textContent = fullText;
                                            
                                            // Track first response
                                            if (!firstResponseTime) {
                                                firstResponseTime = Date.now();
                                                testResults.parallel.firstResponse = modelId;
                                                document.getElementById(`card-${modelId}`).classList.add('first-response');
                                                document.getElementById(`card-${modelId}`).querySelector('.timing-info').textContent = 
                                                    `üöÄ FIRST RESPONSE! (${firstResponseTime - testResults.parallel.startTime}ms)`;
                                            }
                                        }
                                    } catch (e) {
                                        console.warn('Error parsing chunk:', e);
                                    }
                                }
                            }
                        }

                        const endTime = Date.now();
                        const responseTime = endTime - startTime;
                        responses[modelId] = { text: fullText, responseTime };
                        
                        document.getElementById(`card-${modelId}`).querySelector('.timing-info').textContent = 
                            `‚úÖ Completed in ${responseTime}ms`;
                        
                        responseCount++;
                        return { modelId, responseTime, text: fullText };
                        
                    } catch (error) {
                        const endTime = Date.now();
                        const responseTime = endTime - startTime;
                        document.getElementById(`card-${modelId}`).querySelector('.timing-info').textContent = 
                            `‚ùå Failed after ${responseTime}ms: ${error.message}`;
                        return { modelId, error: error.message, responseTime };
                    }
                });

                const results = await Promise.allSettled(promises);
                testResults.parallel.endTime = Date.now();
                testResults.parallel.allResponses = results;
                
                const totalTime = testResults.parallel.endTime - testResults.parallel.startTime;
                status.textContent = `‚úÖ Parallel test completed in ${totalTime}ms. First response: ${testResults.parallel.firstResponse || 'None'}`;
                status.className = 'status success';

            } catch (error) {
                testResults.parallel.endTime = Date.now();
                status.textContent = `‚ùå Error: ${error.message}`;
                status.className = 'status error';
            } finally {
                btn.disabled = false;
            }
        }

        // Test duplicate prompt fix
        async function testDuplicateFix() {
            const btn = document.getElementById('duplicateBtn');
            const status = document.getElementById('duplicateStatus');
            const response = document.getElementById('duplicateResponse');
            
            btn.disabled = true;
            status.style.display = 'block';
            status.textContent = 'Testing duplicate prompt fix...';
            status.className = 'status info';
            response.textContent = '';
            
            testResults.duplicate.startTime = Date.now();
            
            try {
                // This test would need to check the actual request being sent
                // For now, we'll simulate by checking if the message appears twice in the request
                const testMessage = 'Test message for duplicate check';
                
                const res = await fetch('/api/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        path: 'http://13.61.23.21:8080/v1/chat/completions',
                        method: 'POST',
                        headers: {
                            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0IjoiYXUiLCJ2IjoiMC4wLjAiLCJ1dSI6IlYyaG1GM3U4VEpHNXFiNURieUlLM0E9PSIsImF1IjoiaWRnL2ZEMDdVTkdhSk5sNXpXUGZhUT09IiwicyI6ImhyWWJtT29TZFBIOGJQbU4wc2owNGc9PSIsImlhdCI6MTc1NzUwMzE5MH0.yGGnALj9j5aQsZeS59xT5glNfwezMxC3w2oxqiCUpo0'
                        },
                        body: {
                            model: 'gpt-5-2025-08-07',
                            messages: [{ role: 'user', content: testMessage }],
                            max_tokens: 50,
                            stream: true
                        }
                    })
                });

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${await res.text()}`);
                }

                const reader = res.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let fullText = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.trim() === '' || line.trim() === 'data: [DONE]') continue;
                        
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                const chunk = data.choices?.[0]?.delta?.content;
                                
                                if (chunk) {
                                    fullText += chunk;
                                    response.textContent = fullText;
                                }
                            } catch (e) {
                                console.warn('Error parsing chunk:', e);
                            }
                        }
                    }
                }

                testResults.duplicate.endTime = Date.now();
                testResults.duplicate.success = true;
                
                const totalTime = testResults.duplicate.endTime - testResults.duplicate.startTime;
                status.textContent = `‚úÖ Duplicate test completed in ${totalTime}ms. Check console for request details.`;
                status.className = 'status success';

            } catch (error) {
                testResults.duplicate.endTime = Date.now();
                const totalTime = testResults.duplicate.endTime - testResults.duplicate.startTime;
                status.textContent = `‚ùå Error after ${totalTime}ms: ${error.message}`;
                status.className = 'status error';
                console.error('Duplicate test error:', error);
            } finally {
                btn.disabled = false;
            }
        }

        // Run performance test
        async function runPerformanceTest() {
            const btn = document.getElementById('perfBtn');
            const results = document.getElementById('perfResults');
            
            btn.disabled = true;
            results.textContent = 'Running performance test...\n';
            
            try {
                // Run all tests
                await testGPT5Timeout();
                await new Promise(resolve => setTimeout(resolve, 1000));
                await testParallelRequests();
                await new Promise(resolve => setTimeout(resolve, 1000));
                await testDuplicateFix();
                
                // Generate report
                const report = `Performance Test Report
================================

GPT-5 Timeout Test:
- Success: ${testResults.gpt5.success ? '‚úÖ' : '‚ùå'}
- Duration: ${testResults.gpt5.endTime ? testResults.gpt5.endTime - testResults.gpt5.startTime : 'N/A'}ms

Parallel Requests Test:
- First Response: ${testResults.parallel.firstResponse || 'None'}
- Total Duration: ${testResults.parallel.endTime ? testResults.parallel.endTime - testResults.parallel.startTime : 'N/A'}ms
- Responses: ${testResults.parallel.allResponses.length}

Duplicate Fix Test:
- Success: ${testResults.duplicate.success ? '‚úÖ' : '‚ùå'}
- Duration: ${testResults.duplicate.endTime ? testResults.duplicate.endTime - testResults.duplicate.startTime : 'N/A'}ms

Summary:
- Timeout issues should be resolved with increased timeouts
- Parallel requests should show first response quickly
- Duplicate prompts should be eliminated
- Overall performance should be smoother`;

                results.textContent = report;

            } catch (error) {
                results.textContent = `Error during performance test: ${error.message}`;
            } finally {
                btn.disabled = false;
            }
        }
    </script>
</body>
</html>
