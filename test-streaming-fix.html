<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Streaming Fix</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .response {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            min-height: 100px;
            white-space: pre-wrap;
            font-family: monospace;
            border: 1px solid #e9ecef;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .status {
            padding: 5px 10px;
            border-radius: 3px;
            margin: 5px 0;
            font-weight: bold;
        }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Streaming Fix Test</h1>
        <p>This page tests the updated Netlify Functions to ensure real-time streaming works properly.</p>
        
        <div class="test-section">
            <h3>Test 1: Streaming Response (Real-time)</h3>
            <p>This should show text appearing character by character as it's received.</p>
            <button onclick="testStreaming()" id="streamBtn">Test Streaming</button>
            <div id="streamStatus" class="status info" style="display: none;">Testing streaming...</div>
            <div id="streamResponse" class="response"></div>
        </div>

        <div class="test-section">
            <h3>Test 2: Non-Streaming Response</h3>
            <p>This should show the complete response at once.</p>
            <button onclick="testNonStreaming()" id="nonStreamBtn">Test Non-Streaming</button>
            <div id="nonStreamStatus" class="status info" style="display: none;">Testing non-streaming...</div>
            <div id="nonStreamResponse" class="response"></div>
        </div>

        <div class="test-section">
            <h3>Test 3: Performance Comparison</h3>
            <p>Compare timing between streaming and non-streaming responses.</p>
            <button onclick="comparePerformance()" id="perfBtn">Compare Performance</button>
            <div id="perfResults" class="response"></div>
        </div>
    </div>

    <script>
        // Test streaming response
        async function testStreaming() {
            const btn = document.getElementById('streamBtn');
            const status = document.getElementById('streamStatus');
            const response = document.getElementById('streamResponse');
            
            btn.disabled = true;
            status.style.display = 'block';
            status.textContent = 'Testing streaming...';
            status.className = 'status info';
            response.textContent = '';
            
            const startTime = Date.now();
            let firstChunkTime = null;
            let chunkCount = 0;
            
            try {
                const res = await fetch('/api/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        path: 'http://13.61.23.21:8080/v1/chat/completions',
                        method: 'POST',
                        headers: {
                            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0IjoiYXUiLCJ2IjoiMC4wLjAiLCJ1dSI6IlYyaG1GM3U4VEpHNXFiNURieUlLM0E9PSIsImF1IjoiaWRnL2ZEMDdVTkdhSk5sNXpXUGZhUT09IiwicyI6ImhyWWJtT29TZFBIOGJQbU4wc2owNGc9PSIsImlhdCI6MTc1NzUwMzE5MH0.yGGnALj9j5aQsZeS59xT5glNfwezMxC3w2oxqiCUpo0'
                        },
                        body: {
                            model: 'gpt-5-2025-08-07',
                            messages: [{ role: 'user', content: 'Write a short story about a robot learning to paint. Make it exactly 3 sentences long.' }],
                            max_tokens: 150,
                            stream: true
                        }
                    })
                });

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${await res.text()}`);
                }

                const reader = res.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let fullText = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.trim() === '' || line.trim() === 'data: [DONE]') continue;
                        
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                const chunk = data.choices?.[0]?.delta?.content;
                                
                                if (chunk) {
                                    if (!firstChunkTime) {
                                        firstChunkTime = Date.now();
                                        status.textContent = `First chunk received in ${firstChunkTime - startTime}ms`;
                                        status.className = 'status success';
                                    }
                                    
                                    fullText += chunk;
                                    response.textContent = fullText;
                                    chunkCount++;
                                }
                            } catch (e) {
                                console.warn('Error parsing chunk:', e);
                            }
                        }
                    }
                }

                const totalTime = Date.now() - startTime;
                status.textContent = `Streaming complete! ${chunkCount} chunks in ${totalTime}ms (first chunk: ${firstChunkTime - startTime}ms)`;
                status.className = 'status success';

            } catch (error) {
                status.textContent = `Error: ${error.message}`;
                status.className = 'status error';
                console.error('Streaming test error:', error);
            } finally {
                btn.disabled = false;
            }
        }

        // Test non-streaming response
        async function testNonStreaming() {
            const btn = document.getElementById('nonStreamBtn');
            const status = document.getElementById('nonStreamStatus');
            const response = document.getElementById('nonStreamResponse');
            
            btn.disabled = true;
            status.style.display = 'block';
            status.textContent = 'Testing non-streaming...';
            status.className = 'status info';
            response.textContent = '';
            
            const startTime = Date.now();
            
            try {
                const res = await fetch('/api/proxy', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        path: 'http://13.61.23.21:8080/v1/chat/completions',
                        method: 'POST',
                        headers: {
                            'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0IjoiYXUiLCJ2IjoiMC4wLjAiLCJ1dSI6IlYyaG1GM3U4VEpHNXFiNURieUlLM0E9PSIsImF1IjoiaWRnL2ZEMDdVTkdhSk5sNXpXUGZhUT09IiwicyI6ImhyWWJtT29TZFBIOGJQbU4wc2owNGc9PSIsImlhdCI6MTc1NzUwMzE5MH0.yGGnALj9j5aQsZeS59xT5glNfwezMxC3w2oxqiCUpo0'
                        },
                        body: {
                            model: 'gpt-5-2025-08-07',
                            messages: [{ role: 'user', content: 'Write a short story about a robot learning to paint. Make it exactly 3 sentences long.' }],
                            max_tokens: 150,
                            stream: false
                        }
                    })
                });

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}: ${await res.text()}`);
                }

                const data = await res.json();
                const text = data.choices?.[0]?.message?.content || 'No response';
                
                const totalTime = Date.now() - startTime;
                response.textContent = text;
                status.textContent = `Non-streaming complete! Total time: ${totalTime}ms`;
                status.className = 'status success';

            } catch (error) {
                status.textContent = `Error: ${error.message}`;
                status.className = 'status error';
                console.error('Non-streaming test error:', error);
            } finally {
                btn.disabled = false;
            }
        }

        // Compare performance
        async function comparePerformance() {
            const btn = document.getElementById('perfBtn');
            const results = document.getElementById('perfResults');
            
            btn.disabled = true;
            results.textContent = 'Running performance comparison...\n';
            
            try {
                // Test streaming
                const streamStart = Date.now();
                await testStreaming();
                const streamTime = Date.now() - streamStart;
                
                // Wait a bit
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Test non-streaming
                const nonStreamStart = Date.now();
                await testNonStreaming();
                const nonStreamTime = Date.now() - nonStreamStart;
                
                results.textContent = `Performance Comparison Results:
                
Streaming Response:
- Total time: ${streamTime}ms
- First chunk time: Check status above
- Chunks received: Check status above

Non-Streaming Response:
- Total time: ${nonStreamTime}ms
- Response received all at once

Analysis:
- Streaming should show first chunk much faster than total time
- Non-streaming waits for complete response
- If streaming shows first chunk quickly, the fix is working!`;

            } catch (error) {
                results.textContent = `Error during comparison: ${error.message}`;
            } finally {
                btn.disabled = false;
            }
        }
    </script>
</body>
</html>
